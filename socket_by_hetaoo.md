---
title: socket理解 by hetaoo
tags: socket,socket理解
---

## **前奏：** 网络中进程之间如何通信
本地的进程间通信有很多种方式，总体可以分为下面4类：
* 消息传递（管道、FIFO、消息队列）
* 同步（互斥量、条件变量、消息队列）
* 共享内存（匿名的和具名的）
* 远程过程调用（ RPC等）

在本地可以通过PID唯一标记一个进程，但是在网络中不可以通过PID标记；但是TCP\IP协议簇帮我们解决了这个问题，网络层的**ip地址**可以以为标识网络中的主机，传输层的**协议+端口** 可以标识主机中的应用程序（进程）。利用**ip+协议+端口**就可以标识网络的一个进程，网络中进程通信就可以用这个标识的进程与其它进程进行交互。

## socket概念以及出现的缘由
### 什么是scoket？
Socket是连接运行在网络上的两个程序间的双向通讯的端点。
> Socket是应用层与TCP/IP协议族通信的中间软件抽象层，它是一组接口。在设计模式中，Socket其实就是一个门面（Facade）模式，它把复杂的TCP/IP协议族隐藏在Socket接口后面，对用户来说，一组简单的接口就是全部，让Socket去组织数据，以符合指定的协议。

> 其实就是：网络上的两个程序（进程）若想通信，则要通过一个双向的通信连接实现数据的交换，这个连接的一端称为一个socket。

### 其与tcp/ip之间的关系

![协议间关系][1]
TCP/IP协议族包括运输层、网络层、链路层。此时没有socket，每个应用程序采用不同的协议都需要单个实现。

![采用socket协议间关系][2]
它将底层的协议抽象成一个接口，应用层可以通过socket操作复杂的tcp、udp等。


## socket通信过程
使用TCP/IP协议的应用程序通常采用应用编程接口：UNIX  BSD的套接字（socket）和UNIX System V的TLI（已经被淘汰），来实现网络进程之间的通信。就目前而言，几乎所有的应用程序都是采用socket。

socket起源于Unix，而Unix/Linux基本哲学之一就是“一切皆文件”，都可以用“打开open –> 读写write/read –> 关闭close”模式来操作。

![socket --> tcp 通信过程][3]
**过程详解：** 服务器程序将一个套接字绑定到一个特定的端口（一个应用），并通过此套接字等待和监听客户的连接请求。
客户程序根据服务器程序所在的主机名和端口号发出连接请求。

![客户端请求连接服务端][4]
如果一切正常，服务器接受连接请求。并获得一个新的绑定到不同端口地址的套接字。（不可能有两个程序同时占用一个端口）。
客户和服务器通过读写套接字进行通讯。

![客户端和服务端建立连接][5]

**过程总结：** 使用ServerSocket和Socket实现服务器端和客户端的Socket通信

1. 服务器socket监听端口号请求，随时准备接收客户端发来的连接，这时候服务器的socket并没有被打开
2. 客户端创建socket
3. 客户端打开socket，根据服务器ip地址和端口号试图连接服务器socket
4. 服务器socket接收到客户端socket请求，被动打开，开始接收客户端请求，直到客户端返回连接信息。这时候socket进入阻塞状态，所谓阻塞即accept()方法一直到客户端返回连接信息后才返回，开始接收下一个客户端谅解请求
5. 客户端连接成功，向服务器发送连接状态信息
6. 服务器accept方法返回，连接成功 （连接建立好后，服务器端和客户端的输入流和输出流就互为彼此，即一端的输出流是另一端的输入流）
7. 客户端向socket写入信息
8. 服务器读取信息
9. 客户端关闭
10. 服务器端关闭

![scoket --> udp 通信过程][6]
udp和tcp很大的区别就是服务端和客户端不需要建立连接，所以需要在recvfrom、sendto指定地址信息

### UDP和TCP比较

内容|TCP|UDP
------------ | ------------- | -------------
|对系统要求|较多|较少|
|程序结构|复杂|简单|
|数据正确性|保证|不保证|
|数据顺序性|保证|不保证|
|地址信息确定|在connect、accept确定|sendto、recvform每次都需要指定
|数据发送|分片发送|报文发送|

* TCP优缺点：
> 优点：
1．TCP提供以认可的方式显式地创建和终止连接。
2．TCP保证可靠的、顺序的（数据包以发送的顺序接收）以及不会重复的数据传输。
3．TCP处理流控制。
4．如果数据没有传送到，则TCP套接口返回一个出错状态条件。
5．TCP通过保持连续并将数据块分成更小的分片来处理大数据块。
缺点： TCP在转移数据时必须创建（并保持）一个连接。这个连接给通信进程增加了开销，让它比UDP速度要慢。

* UDP优缺点：
>优点：
>1．UDP不要求保持一个连接
2．UDP没有因接收方认可收到数据包（或者当数据包没有正确抵达而自动重传）而带来的开销。
3．在一个数据包连接一个数据包的基础上，UDP要求的网络带宽比TDP更小。
缺点：UDP数据容易出现丢失，协议没有规定相应的流控制方式，不会保证数据的顺序到达，开发控制不当，可能导致数据风暴问题。

## scoket连接与tcp连接
创建Socket连接时，可以指定使用的传输层协议，Socket可以支持不同的传输层协议（TCP或UDP），当使用TCP协议进行连接时，该Socket连接就是一个TCP连接。

## scoket连接与http连接
由于通常情况下Socket连接就是TCP连接，因此Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。但在实际网络应用中，客户端到服务器之间的通信往往需要穿越多个中间节点，例如路由器、网关、防火墙等，大部分防火墙默认会关闭长时间处于非活跃状态的连接而导致 Socket 连接断连，因此需要通过轮询告诉网络，该连接处于活跃状态。

HTTP连接使用的是“请求—响应”的方式，不仅在请求时需要先建立连接，而且需要客户端向服务器发出请求后，服务器端才能回复数据。
很多情况下，需要服务器端主动向客户端推送数据，保持客户端与服务器数据的实时与同步。此时若双方建立的是Socket连接，服务器就可以直接将数据传送给客户端；若双方建立的是HTTP连接，则服务器需要等到客户端发送一次请求后才能将数据传回给客户端，因此，客户端定时向服务器端发送连接请求，不仅可以保持在线，同时也是在“询问”服务器是否有新的数据，如果有就将数据传给客户端。

*附： 摘自（http://www.cnblogs.com/Jessy/p/3535612.html）
### tcp三次握手（建立连接） 和tcp四次挥手（断开连接）
#### tcp连接控制
##### tcp使用窗口机制进行流量控制

* 什么是窗口？
连接建立时，各端分配一块缓冲区用来存储接收的数据，并将缓冲区的尺寸发送给另一端，接收方发送的确认信息中包含了自己剩余的缓冲区尺寸，剩余缓冲区空间的数量叫做窗口。

* tcp流程控制（滑动窗口）
![滑动窗口][7]

![三次握手、四次挥手示意图][8]

三次握手建立一个连接：
1. 第一次握手：建立连接时，客户端A发送SYN包（SYN=j）到服务器B，并进入SYN_SEND状态，等待服务器B确认。
2. 第二次握手：服务器B收到SYN包，必须确认客户A的SYN（ACK=j+1），同时自己也发送一个SYN包（SYN=k），即SYN+ACK包，此时服务器B进入SYN_RECV状态。
3. 第三次握手：客户端A收到服务器B的SYN＋ACK包，向服务器B发送确认包ACK（ACK=k+1），此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手。
完成三次握手，客户端与服务器开始传送数据。

**确认号：其数值等于发送方的发送序号 +1(即接收方期望接收的下一个序列号)。**

四次握手断开一个连接：
1. 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送。 
2. 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号。 
3. 服务器B关闭与客户端A的连接，发送一个FIN给客户端A。 
4. 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1


各个状态的意义如下： 
* LISTEN - 侦听来自远方TCP端口的连接请求； 
* SYN-SENT -在发送连接请求后等待匹配的连接请求； 
* SYN-RECEIVED - 在收到和发送一个连接请求后等待对连接请求的确认； 
* ESTABLISHED- 代表一个打开的连接，数据可以传送给用户； 
* FIN-WAIT-1 - 等待远程TCP的连接中断请求，或先前的连接中断请求的确认；
* FIN-WAIT-2 - 从远程TCP等待连接中断请求； 
* CLOSE-WAIT - 等待从本地用户发来的连接中断请求； 
* CLOSING -等待远程TCP对连接中断的确认； 
* LAST-ACK - 等待原来发向远程TCP的连接中断请求的确认； 
* TIME-WAIT -等待足够的时间以确保远程TCP接收到连接中断请求的确认； 
* CLOSED - 没有任何连接状态；

> 客户端TCP状态迁移：
CLOSED->SYN_SENT->ESTABLISHED->FIN_WAIT_1->FIN_WAIT_2->TIME_WAIT->CLOSED

>服务器TCP状态迁移：
CLOSED->LISTEN->SYN收到->ESTABLISHED->CLOSE_WAIT->LAST_ACK->CLOSED




## 


  [1]: https://www.github.com/hetaoo/daily_discussion/raw/master/image/1503026621694.jpg
  [2]: https://www.github.com/hetaoo/daily_discussion/raw/master/image/1503027033800.jpg
  [3]: https://www.github.com/hetaoo/daily_discussion/raw/master/image/1503027511289.jpg
  [4]: https://www.github.com/hetaoo/daily_discussion/raw/master/image/1503037613965.jpg
  [5]: https://www.github.com/hetaoo/daily_discussion/raw/master/image/1503037640845.jpg
  [6]: https://www.github.com/hetaoo/daily_discussion/raw/master/image/1503039855509.jpg
  [7]: https://www.github.com/hetaoo/daily_discussion/raw/master/image/1503042899146.jpg

  [8]: https://www.github.com/hetaoo/daily_discussion/raw/master/image/1503043085258.jpg