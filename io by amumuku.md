
**IO简单操作理解**


传统文件IO操作

![enter description here][1]

进程执行 I/O 操作，归结起来，也就是向操作系统发出请求，让它要么把缓冲区里的数据排干（写），要么用数据把缓冲区填满（读）。图中明显忽略了很多细节，仅显示了涉及到的基本步骤。

  *1 用户空间概念*

    1）用户空间是常规进程所在区域。JVM 就是常规进程，驻守于用户空间。
    2) 用户空间是非特权区域：比如，在该区域执行的代码就不能直接访问硬件设备。

 *2 内核空间概念*

    1) 内核空间是操作系统所在区域。
    2) 内核代码有特别的权力：它能与设备控制器通讯，控制着用户区域进程的运行状态
    3) 所有 I/O 都直接或者间接通过内核空间

 *3.操作基本步骤*

	1）当进程请求 I/O 操作的时候，它执行一个系统调用（有时称为陷阱）将控制权移交给内核。
	2）C/C++程序员所熟知的底层函数 open( )、read( )、write( )和 close( )要做的无非就是建立和执行适当的系统调用。
	3) 当内核以这种方式被调用，它随即采取任何必要步骤，找到进程所需数据，并把数据传送到用户空间内的指定缓冲区。
	4) 内核试图对数据进行高速缓存或预读取，因此进程所需数据可能已经在内核空间里了。如果是这样，该数据只需简单地拷贝出来即可。如果数据不在内核空间，则进程被挂起，内核着手把数据读进内存。

内存映射IO操作

![enter description here][2]

 *1 虚拟内存*
 	
	1) 一个以上的虚拟地址可指向同一个物理内存地址。
    2) 虚拟内存空间可大于实际可用的硬件内存。
   

 *2. 与传统IO操作比较*
 
	1）传统文件IO操作提到，设备控制器不能通过 DMA 直接存储到用户空间，但通过把内核空间地址与用户空间的虚拟地址映射到同一个物理地址；
	2）这样，DMA 硬件（只能访问物理内存地址）就可以填充对内核与用户空间进程同时可见的缓冲区；
	3）省去了内核与用户空间的往来拷贝。

  


 


  [1]: ./images/201708211424.jpg "201708211424"
  [2]: ./images/20170821145036.jpg "20170821145036"